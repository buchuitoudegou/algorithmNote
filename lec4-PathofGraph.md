# lec4 图中的路径
## BFS
DFS能找到从起点到其他点的路径，但不能保证找到最短的。
```
dist(s) = 0
Q = [s]
while Q is not empty
  u = eject(Q)
  for all edges(u, v) in E
    if dist(v) = INF
      inject(Q, v)
      dist(v) = dist(s) + 1
```

#### 复杂度：O(V+E)

### 隐式图的BFS
问题中没有给出明确的图结构，图需要一边做BFS一边构造

#### 8数码问题
标有1-8的八块正方形数码拍任意地放在3x3的数码盘上。每次只能将与空格相邻的数码牌与空格交换。将任意摆放的数码盘以最少的步数摆成某种特殊的排列。<br>

将排列状态当成一个节点。

## 带权图的单源最短路
### 简单想法一
将长度换成节点，然后对新图进行BFS。当长度很大时，插入的节点太多，不实际。
### 想法二Alarm clocks
每秒走一步，走到节点时响应。
### Dijkstra算法
```
for all u in V
  dist(u) = INF
  prev(u) = nil
dist(s) = 0
H = makequeue(V) // dist-value as keys优先队列
while H is not empty
  u = deletemin(H)
  for all edges (u, v) in E
    if dist(v) > dist(u) + l(u, v)
      dist(v) = dist(u) + l(u, v)
      prev(v) = u
      decreaseKey(H, v) // 更新到源点的距离值
```
用不同数据结构实现H会有不同的复杂度。
## 二分堆
小根堆：父节点一定比子节点要小，根节点是最小的<br>
大根堆：父节点一定比子节点要大，根节点是最大的<br>
堆排序：
1. 删除根节点，并从堆底部选出最右边的节点替代为根节点
2. 维护这个大根堆/小根堆。如果有父节点比子节点大，则将子节点中较小者换到父节点。
3. 重复第一步，直到堆为空

### 负权图，Dijkstra算法无法求得最短路（有向图）
dijkstra的问题在于，默认初始设置了到源点的dist为某个点到源的最小值，也就是否认了，从其他更大的dist值的点出发，经过一个负数权值的边到达该点会有更小dist值的可能性。我们可以通过一下的update操作来更新新加入点到已经过的点的距离是否会由于负数权的边发生变化。
```
procedure update(all (u,v) in E)
  dist(v) = min{dist(v), dist(u) + l(u,v)}
```
update操作在每次迭代将所有点、边的dist值更新一遍。但是，要确保这种更新的正确性，我们必须保证，更新顺序按照src到sink的路径。然而，在找出正确路径之前，我们是无法确保这一点的。那么只要我们重复更新V-1次（V为点数量）就可以保证更新出最短的从src到sink的路径。为什么呢？假设src到sink需要依次经过a1,a2,a3....an个点。那么src到a1的路径就是s->a1，也就是说，无论更新顺序是什么，第一次迭代总能把a1到src的最短路径求出。而a2到src最短的路径呢？假设更新顺序a2在a1之前，也就是说，a2在第一次迭代中，并没有办法找出最短路径，但在第二次迭代中，由于a1在第一次迭代中已经找到了最短路径，那么a2就一定可以在第二次迭代中找到最短路径。由此，我们可以看出，当更新顺序倒序，即{an....a1}时，an会在第n次迭代找到最短路径。由此，我们也可以推断出，在第V-1次迭代，就能找到src到sink的最短路径。
